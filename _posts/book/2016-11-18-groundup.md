---
layout: post
title:  "Programming From The Ground Up"
date:   2016-11-18 16:45:00
categories: book
---

By Jonathan Bartlett

> Trying to be a programmer without understanding how a CPU works is like trying to practice medicine without learning anatomy. Sure, you can have limited success curing patients with medical advice gleaned from Google, but on the whole you're going to be a pretty bad doctor. For those who missed out on learning assembly language, I highly recommend working through this book, even if you'll never program in assembly again. I promise that all kind of lights will go on in your head and you'll be a vastly better programmer.
>
> -- <cite>[Joel Spolsky](http://www.joelonsoftware.com/)</cite>

The author gives an introduction to Programming using Linux Assembly Language


## 1. Introduction

Essentially there are 3 kinds of languages:

* **Machine Language**

  What the computer actually sees and deals with. Every Command is a number or a sequence of numbers.
  
* **Assembly Language**

  The same as machine language, but every instruction is represented by a letter sequence which is easier for a human to remember. Plus some other small improvements.
  
* **High-Level Language**

  Used to make programming easier with a more natural language. A single command is translated to multiple instructions in machine language.



## 2. Computer Architecture

Modern computers are based on Von Neumann architecture: A Division into two main parts - the CPU and the Memory.


### Structure of Computer Memory

Can be compared to room full of post boxes. Each location has a number and each location has the same fixed size length in which a single number can be stored.

There is no difference between a program or data stored in memory except how it is used by the CPU. Both are stored and accessed the same way.


### The CPU

The CPU reads an instruction from memory and executes it: **fetch-execute cycle**. In order to accomplish this, it has the following elements:

* **Program Counter**
* **Instruction Decoder**
* **Data Bus**
* **General-purpose Registers**
* **Arithmetic and Logic Unit**

The **program counter** holds the address of the memory location which contains the instruction which is going to be executed next.

The CPU fetches a number from this memory location and passes it on to the **instruction decoder**. This figures out what the instruction means (addition, subtraction, data movement, etc.) and which locations of memory are going to be needed.

Then the **data bus** is used to fetch from the memory location which are needed for the calculation. The data bus can be seen on a mainboard as wires which go out from the memory to the CPU.

The CPU itself has some high-speed memory locations called **registers**. There are different general- and specia-purpose registers.

Now that the CPU has everything it needs, it passes the decoded instruction and the data to the **arithmetic and logic unit** for the actual processing. The resulta of the calculation are placed in a register or on the data bus for memory storage.


### Some Terms

Each storage location in memory is referred to by a number called it's **address**. The size of a single storage location is called a **byte** which is number between 0 and 255.
On a 32-bit CPU the registers are 4 bytes long. This is called the computers **word** size. This fits about 4 billion values. Memory addresses are as long as the word size and therefore fit into a register.

When an address is stored in memory it is called a **pointer**.


### Data Accessing Methods

* **immediate mode**

  The data is embedded in the instruction itself.
  
* **register addressing mode**

  The data is found in a register.
  
* **direct addressing mode**

  The instruction is provided with an address of memory from where to load the data e.g. into a register.
  
* **indexed addressing mode**

  The instruction is provided with an address of memory and an **index register** used as offset. On x86 processors you can also give a **multiplier** to index a whole word or larger record at a time.

* **indirect addressing mode**

  The instruction is provided with a register which contains a **pointer** to where the data is in memory.
  
* **base pointer addressing mode**

  Like indirect addressing mode, but including an offset


## 3. First Programs

```
	        .section .data

        	.section .text
        	.globl _start

    _start:
	        movl $1, %eax 	# 1 is the code for the exit system call
	
         	movl $0, %ebx	# 0 is the return code

        	int $0x80	# control transfer from user space to kernel
		            	# by interrupt 0x80
			
```
