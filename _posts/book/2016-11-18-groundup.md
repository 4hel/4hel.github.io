---
layout: post
title:  "Programming From The Ground Up"
date:   2016-11-18 16:45:00
categories: book
---

By Jonathan Bartlett

> Trying to be a programmer without understanding how a CPU works is like trying to practice medicine without learning anatomy. Sure, you can have limited success curing patients with medical advice gleaned from Google, but on the whole you're going to be a pretty bad doctor. For those who missed out on learning assembly language, I highly recommend working through this book, even if you'll never program in assembly again. I promise that all kind of lights will go on in your head and you'll be a vastly better programmer.
>
> -- <cite>[Joel Spolsky](http://www.joelonsoftware.com/)</cite>

The author gives an introduction to Programming using Linux Assembly Language


## 1. Introduction

Essentially there are 3 kinds of languages:

* **Machine Language**

  What the computer actually sees and deals with. Every Command is a number or a sequence of numbers.
  
* **Assembly Language**

  The same as machine language, but every instruction is represented by a letter sequence which is easier for a human to remember. Plus some other small improvements.
  
* **High-Level Language**

  Used to make programming easier with a more natural language. A single command is translated to multiple instructions in machine language.



## 2. Computer Architecture

Modern computers are based on Von Neumann architecture: A Division into two main parts - the CPU and the Memory.


### Structure of Computer Memory

Can be compared to room full of post boxes. Each location has a number and each location has the same fixed size length in which a single number can be stored.

There is no difference between a program or data stored in memory except how it is used by the CPU. Both are stored and accessed the same way.


### The CPU

The CPU reads an instruction from memory and executes it: **fetch-execute cycle**. In order to accomplish this, it has the following elements:

* **Program Counter**
* **Instruction Decoder**
* **Data Bus**
* **General-purpose Registers**
* **Arithmetic and Logic Unit**

The **program counter** holds the address of the memory location which contains the instruction which is going to be executed next.

The CPU fetches a number from this memory location and passes it on to the **instruction decoder**. This figures out what the instruction means (addition, subtraction, data movement, etc.) and which locations of memory are going to be needed.

Then the **data bus** is used to fetch from the memory location which are needed for the calculation. The data bus can be seen on a mainboard as wires which go out from the memory to the CPU.

The CPU itself has some high-speed memory locations called **registers**. There are different general- and specia-purpose registers.

Now that the CPU has everything it needs, it passes the decoded instruction and the data to the **arithmetic and logic unit** for the actual processing. The resulta of the calculation are placed in a register or on the data bus for memory storage.


### Some Terms

Each storage location in memory is referred to by a number called it's **address**. The size of a single storage location is called a **byte** which is number between 0 and 255.
On a 32-bit CPU the registers are 4 bytes long. This is called the computers **word** size. This fits about 4 billion values. Memory addresses are as long as the word size and therefore fit into a register.

When an address is stored in memory it is called a **pointer**.


### Data Accessing Methods

* **immediate mode**

  The data is embedded in the instruction itself.
  
* **register addressing mode**

  The data is found in a register.
  
* **direct addressing mode**

  The instruction is provided with an address of memory from where to load the data e.g. into a register.
  
* **indexed addressing mode**

  The instruction is provided with an address of memory and an **index register** used as offset. On x86 processors you can also give a **multiplier** to index a whole word or larger record at a time.

* **indirect addressing mode**

  The instruction is provided with a register which contains a **pointer** to where the data is in memory.
  
* **base pointer addressing mode**

  Like indirect addressing mode, but including an offset


## 3. First Programs

The Programs demonstrated in this chapter are in 32-bit assembly language. This is what the book uses, but is not up to date. In 64-bit assembly one would use the **64-bit register %rax** instead of the **32-bit %eax**. And accordinly the **movq** instruction instead of **movl**.

## Exercise 1

```
	        .section .data

        	.section .text
        	.globl _start

    _start:
	        movl $1, %eax 	# 1 is the code for the exit system call
	
         	movl $0, %ebx	# 0 is the return code

        	int $0x80	# control transfer from user space to kernel
		            	# by interrupt 0x80
			
```

### Assembling and Linking

The source is asssembled to an object file:

```bash
$ as chap3ex1.s -o exit.o
```

The object file is then linked to an executable binary

```bash
$ ld exit.o -o exit
```

More info on object files and linking can be found [**here**](http://www.tenouk.com/Bufferoverflowc/Bufferoverflow1c.html)


### Outline of a program

Anything starting with a period like `.section .data` is a **pseudo operation** (or **assembler directive**). These are not translated directly into a machine instructions but handled by the assembler differently. The .data section can contain static data like numbers or strings. The .text section contains the machine instructions.

The directive `.globl _start` makes _start a global **symbol**. Meaning it is visible to the linker instead of beeing discarded after assembly. _start is special symbol that is always needed because it marks the beginning of the program, which is needed for *loading*. Symbols are going to be replaced by something else by either the assembler or the linker. They are used to reference **locations** of data or program by name.

The line `_start:` is a label. A **label** is a symbol with a colon. When the program is assembled, each data value and each instruction is getting an address. The label tells the assembler that the symbols value is the address of the element following the label.

The instruction `movl $1, %eax` writes the number 1 into general purpose register %eax. A **number liteal** is indicated by the $-sign which leads to immediate mode data access.

The line `int $0x80` triggers an **interrupt** which interrupts the program flow and transfers the cpu control to the **interrupt handler** which was set up by the linux kernel. This way a **system call** is done.

## Exercise 2

The source can be found on [GitHub](https://github.com/4hel/groundup/blob/master/chap3ex2.s)

Some \"ifs\" like `jmp`, `je` or `jle` are used for **flow control**.

A list of `.long` values is needed in memory, so is created in the `.section .data` under the label `data_items:`. Now we can refer to the memory address of the lists first item by using the symbol with the same name. 

In our case, using 32-bit registers, a long value uses 4 bytes. For 64-bit see: [LP64 data model](https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models).

Only 3 **variables** are needed, so everything can stay in registers and must not yet be moved to memory. 

The destination **index register** %edi is incremented in the loop with `incl` to walk through the list.

When two values are compared with the `cmpl` instruction, the result is stored in the **status register** **%eflags**.

### indexed addressing mode

The value currently pointed at by the index is then copied from the data_items list to the %eax register: `movl data_items(,%edi,4), %eax` 

using the schema: `movl ADDRESS(OFFSET,%INDEX_REGISTER,MULTIPLIER), %DESTINATION_REGISTER`

leading to `FINAL_ADDRESS = ADDRESS + OFFSET + ( MULTIPLIER * INDEX )`

### indirect addressing mode

Though not used in the current program it would work like `movl (%eax), %ebx`. Where %eax contains the address from where data is moved to %ebx.

### base pointer addressing mode

Similar to indirect addressing mode, but adding a constant value to the address like: `movl 4(%eax), %ebx` going 4 bytes into the record at which %eax points.

### immediate addressing mode

Is used with literals like $0: `movl $0, %eax`


## 4. Functions

Are used to break programs apart into pieces.

The **parameters** plus the expectation what to do is called the functions **interface**.

A program is composed of many functions. There are often high-level functions which call low-level helper functions. On the lowest level there are the so called **primitive functions** (or just **primitives**) on which everything else is build on top of. Typically the primitives are provided by the operating system.

### How Functions Work

* **function name**

  The name is a symbol for the address of the function. It is created by a label before the functions code.
  
* **function parameters**

  These are data items which are passed to the function in order to do something with it.
  
* **local variables**

  Temporary storage locations which are needed for processing. After return they are thrown away.
  
* **static variables**

  storage locations which are not thrown away after return, but reused every thime the function is called. They cannot be accessed by other parts of the program. Static variables should be avoided because they can cause problems.
  
* **global variables**

  Data storage that is outside of the function, but used by it for processing. This often considered bad practice but a good use case are configuration values.
  
* **return address**

  A special Parameter0 that is not used for processing. It tells the function where the code execution should continou after the function has finished. The `call` instruction automatically passes the the return address to the function. `ret` is used for jumping back to this address for execution.
  
* **return value**
  
  The data which is the result of the processing is passed back to the main program. Most languages have only a single return value.
  
  
How variables are stored and parameters and return values are passed is the languages **calling convention**.

In assembly language any calling convention can be used, but on linux platforms the most popular is the one from the C programming language.


### Assembly Functions using the C Calling Convention

A region of memory is used as the **stack**. The stack starts at the highest address of memory `pushl` pushes a value on top of the the stack, but which is then at the bottom of the stacks memory, which grows up side down in memory. `popl` removes the top element from the stack and places it in a register or memory location of your choice.

The **stack register** %esp does always hold a pointer to the current top of the stack. So `pushl` will subtract 4 from %esp in order to point to the word in the memory segment below the former top. `popl` does add 4 to %esp accordingly.

Before calling a function, the program pushes the parameters onto stack in reverse order. Then the `call` instruction is used. This does two things:

1. The **call** instruction pushes the address of its following instruction onto the stack as return address.
2. Then it changes the **instruction pointer** %eip to point to the address of functions first instruction.

Then the function begins. At this time the stack looks like this:

```
Parameter #N
...
Parameter2
Parameter1
Return Address <--- (%esp)
```
