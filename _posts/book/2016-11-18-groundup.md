---
layout: post
title:  "Programming From The Ground Up"
date:   2016-11-18 16:45:00
categories: book
---

By Jonathan Bartlett

> Trying to be a programmer without understanding how a CPU works is like trying to practice medicine without learning anatomy. Sure, you can have limited success curing patients with medical advice gleaned from Google, but on the whole you're going to be a pretty bad doctor. For those who missed out on learning assembly language, I highly recommend working through this book, even if you'll never program in assembly again. I promise that all kind of lights will go on in your head and you'll be a vastly better programmer.
>
> -- <cite>[Joel Spolsky](http://www.joelonsoftware.com/)</cite>

The author gives an introduction to Programming using Linux Assembly Language


## 1. Introduction

Essentially there are 3 kinds of languages:

* **Machine Language**

  What the computer actually sees and deals with. Every Command is a number or a sequence of numbers.
  
* **Assembly Language**

  The same as machine language, but every instruction is represented by a letter sequence which is easier for a human to remember. Plus some other small improvements.
  
* **High-Level Language**

  Used to make programming easier with a more natural language. A single command is translated to multiple instructions in machine language.



## 2. Computer Architecture

Modern computers are based on Von Neumann architecture: A Division into two main parts - the CPU and the Memory.


### Structure of Computer Memory

Can be compared to room full of post boxes. Each location has a number and each location has the same fixed size length in which a single number can be stored.

There is no difference between a program or data stored in memory except how it is used by the CPU. Both are stored and accessed the same way.


### The CPU

The CPU reads an instruction from memory and executes it: **fetch-execute cycle**. In order to accomplish this, it has the following elements:

* **Program Counter**
* **Instruction Decoder**
* **Data Bus**
* **General-purpose Registers**
* **Arithmetic and Logic Unit**

The **program counter** holds the address of the memory location which contains the instruction which is going to be executed next.

The CPU fetches a number from this memory location and passes it on to the **instruction decoder**. This figures out what the instruction means (addition, subtraction, data movement, etc.) and which locations of memory are going to be needed.

Then the **data bus** is used to fetch from the memory location which are needed for the calculation. The data bus can be seen on a mainboard as wires which go out from the memory to the CPU.

The CPU itself has some high-speed memory locations called **registers**. There are different general- and specia-purpose registers.

Now that the CPU has everything it needs, it passes the decoded instruction and the data to the **arithmetic and logic unit** for the actual processing. The resulta of the calculation are placed in a register or on the data bus for memory storage.


### Some Terms

Each storage location in memory is referred to by a number called it's **address**. The size of a single storage location is called a **byte** which is number between 0 and 255.
On a 32-bit CPU the registers are 4 bytes long. This is called the computers **word** size. This fits about 4 billion values. Memory addresses are as long as the word size and therefore fit into a register.

When an address is stored in memory it is called a **pointer**.


### Data Accessing Methods

* **immediate mode**

  The data is embedded in the instruction itself.
  
* **register addressing mode**

  The data is found in a register.
  
* **direct addressing mode**

  The instruction is provided with an address of memory from where to load the data e.g. into a register.
  
* **indexed addressing mode**

  The instruction is provided with an address of memory and an **index register** used as offset. On x86 processors you can also give a **multiplier** to index a whole word or larger record at a time.

* **indirect addressing mode**

  The instruction is provided with a register which contains a **pointer** to where the data is in memory.
  
* **base pointer addressing mode**

  Like indirect addressing mode, but including an offset


## 3. First Programs

The Programs demonstrated in this chapter are in 32-bit assembly language. This is what the book uses, but is not up to date. In 64-bit assembly one would use the **64-bit register %rax** instead of the **32-bit %eax**. And accordinly the **movq** instruction instead of **movl**.

```
	        .section .data

        	.section .text
        	.globl _start

    _start:
	        movl $1, %eax 	# 1 is the code for the exit system call
	
         	movl $0, %ebx	# 0 is the return code

        	int $0x80	# control transfer from user space to kernel
		            	# by interrupt 0x80
			
```

### Assembling and Linking

The source is asssembled to an object file:

```bash
$ as chap3ex1.s -o exit.o
```

The object file is then linked to an executable binary

```bash
$ ld exit.o -o exit
```

More info on object files and linking can be found [**here**](http://www.tenouk.com/Bufferoverflowc/Bufferoverflow1c.html)


### Outline of a program

Anything starting with a period like `.section .data` is a **pseudo operation** (or **assembler directive**). These are not translated directly into a machine instructions but handled by the assembler differently. The .data section can contain static data like numbers or strings. The .text section contains the machine instructions.

The directive `.globl _start` makes _start a global **symbol**. Meaning it is visible to the linker instead of beeing discarded after assembly. _start is special symbol that is always needed because it marks the beginning of the program, which is needed for *loading*. Symbols are going to be replaced by something else by either the assembler or the linker. They are used to reference **locations** of data or program by name.

The line `_start:` is a label. A **label** is a symbol with a colon. When the program is assembled, each data value and each instruction is getting an address. The label tells the assembler that the symbols value is the address of the element following the label.

The instruction `movl $1, %eax` writes the number 1 into general purpose register %eax. A **number liteal** is indicated by the $-sign which leads to immediate mode data access.

The line `int $0x80` triggers an **interrupt** which interrupts the program flow and transfers the cpu control to the **interrupt handler** which was set up by the linux kernel. This way a **system call** is done.



